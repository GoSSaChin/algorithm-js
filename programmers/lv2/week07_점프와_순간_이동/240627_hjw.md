## 문제 링크

[![PRO]][Link]

## 문제 해석

-   0에서 N까지 `점프`나 `순간이동`으로 간다.
-   `점프`는 K칸을 앞으로 점프, `순간이동`은 (현재까지 온 거리) x 2만큼 이동
-   `순간이동`에는 건전지가 소모되지 않음.
-   가장 건전지를 아끼면서 N까지 갈 때 점프는 몇 칸을 하는가.
-   0에서 시작하면 처음에 무조건 점프를 하지 않으면 `순간이동`을 할 수 없음. 
    그럴 경우 몇 칸을 `점프해야하는가`의 조건을 설정하는 것도 어렵기 때문에 N에서 0으로 이동.

## 최종 제출 코드

-   n에서 출발해서 나누거나 뺀다.
-   이동한 곳이 `홀수일 경우` 이전 단계에서 `더하기`로 홀수 자리로 오게 된 것이므로 k++, `n-1`
-   `짝수일 경우` `순간이동`이므로 `n/2`

```js
function solution(n)
{
    let k = 0
    while(n!==0){
        if(n % 2 === 1){
            k++
            n = n-1
        }else{
            n = n/2
        }
    }
    return k
}
```

## 시간 복잡도

-   `While` 문을 반복할 때마다 N을 2로 나누거나 1을 빼기 때문에 이진 로그와 같은 형태의 반복이 이루어짐.
-   **∴ O(logn)**

<!---------------------------------------------------------------------------->

[PRO]: https://github.com/GoSSaChin/algorithm-js/assets/107768516/67c43b52-bc3f-4571-a249-5519021afbb0
[Link]: https://school.programmers.co.kr/learn/courses/30/lessons/12980
