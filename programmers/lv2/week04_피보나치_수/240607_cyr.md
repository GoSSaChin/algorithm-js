[![PRO]][Link]

## 문제 해석

- 피보나치수 계산
- `n`번째 피보나치 수를 `1234567`로 나눈 나머지 리턴

<br/>

## 최종 제출 코드

```javascript
function solution(n) {
  let arr = [0, 1];

  for (let i = 2; i <= n; i++) {
    arr[i] = (arr[i - 1] + arr[i - 2]) % 1234567;
  }

  return arr[n];
}
```

- F(0) = 0, F(1) = 1이므로 `arr`을 `[0, 1]`로 초기화
- `2`부터 `n`까지 피보나치 수를 계산
  - 단, 각 계산마다 `1234567`로 나눈 나머지를 할당
- 최종적으로 arr[n] return

<br/>

## 시간 복잡도

- `for` 루프가 `n-1`번 실행되므로 O(n)의 시간 복잡도 가짐
- **∴ O(n)**

<br/>

## 메모

- 매 계산마다 `1234567`로 나누는 경우
  - 배열이 저장되는 각 중간 값들이 `1234567` 이하로 유지되므로, 메모리 사용과 계산의 효율성 높임
  - 모든 연산이 작은 수로 제한되기 때문에, 덧셈 연산에서 발생할 수 있는 오버플로 문제 방지
- 최종적으로 `1234567`로 나누는 경우
  - 배열에 저장되는 값들이 매우 커질 수 있음
  - 큰 숫자를 처리하는 데 더 많은 메모리와 시간 소요
  - `n`이 큰 경우, 중간 값들이 매우 커져서 오버플로 문제 발생할 수 있으며, 연산이 비효율적일 수 있음

<!---------------------------------------------------------------------------->

[PRO]: https://github.com/GoSSaChin/algorithm-js/assets/107768516/67c43b52-bc3f-4571-a249-5519021afbb0
[Link]: https://school.programmers.co.kr/learn/courses/30/lessons/12945
